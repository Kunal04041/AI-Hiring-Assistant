# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_PY2GzlpVcioFkBxSIQ4BkuGOc4WaLK4
"""

# 1.Importing Dependencies



import streamlit as st
import google.generativeai as genai
import os
import re

# 2.Setting the Gemini API key from the environment



os.environ["GOOGLE_API_KEY"] = "AIzaSyASL66kKdQvKWJ1xcjH6xdmmT3h2YNakTU" # API Key is hard coded temporarily for ease of use.

api_key = os.getenv("GOOGLE_API_KEY")
if not api_key:
    st.error("Google Gemini API key not found! Please set GOOGLE_API_KEY as an environment variable.")
    st.stop()

genai.configure(api_key=api_key)
model = genai.GenerativeModel('models/gemini-2.5-flash-lite')




# 3.Page Setup


st.set_page_config(page_title="TalentScout Hiring Assistant", layout="centered")
st.title(" TalentScout - AI Hiring Assistant")

st.markdown(
    """
    <small>Privacy Notice: All information you provide is used solely for this simulated hiring assistant demo.
    Your data is temporarily stored in this session only, anonymized when saved, and not shared or persisted anywhere.</small>
    """,
    unsafe_allow_html=True,
)




# 4.Session State Initialization




if "stage" not in st.session_state:
    st.session_state.stage = "intro"
if "conversation" not in st.session_state:
    st.session_state.conversation = []
if "candidate" not in st.session_state:
    st.session_state.candidate = {}
if "questions" not in st.session_state:
    st.session_state.questions = []
if "current_q_index" not in st.session_state:
    st.session_state.current_q_index = 0
if "answers" not in st.session_state:
    st.session_state.answers = {}
if "stored_data" not in st.session_state:
    st.session_state.stored_data = []




# 5.Question stage and prompts




stages = [
    ("full_name", "Please enter your full name."),
    ("email", "Great! What's your email?"),
    ("phone", "Your phone number?"),
    ("location", "Where are you based?"),
    ("experience", "How many years of experience do you have?"),
    ("position", "What position(s) are you applying for?"),
    ("tech_stack", "List your tech stack (languages, tools, DBs)."),
]




# 6.Helper Functions




def is_valid(stage, val):
    """
    Validate user input for a given interview stage.

    Args:
        stage (str): The current stage (e.g., 'email', 'phone', 'experience').
        val (str): User input to validate.

    Returns:
        bool: True if input is valid, else False.
    """
    val = val.strip()
    if stage == "email":
        return "@" in val and "." in val
    if stage == "phone":
        return any(c.isdigit() for c in val)
    if stage == "experience":
        return any(c.isdigit() for c in val)
    return len(val) > 1


def anonymize(candidate_dict):
    """
    Mask sensitive candidate information (email and phone) for privacy.

    """
    anon = candidate_dict.copy()

    # Masking email
    email = anon.get("email", "")
    if email:
        parts = email.split("@")
        if len(parts) == 2:
            local, domain = parts
            if len(local) > 2:
                anon["email"] = local[:2] + "***@" + domain
            else:
                anon["email"] = "***@" + domain

    # Mask phone number
    phone = anon.get("phone", "")
    if phone:
        digits = re.sub(r"\D", "", phone)
        if len(digits) > 3:
            anon["phone"] = "***" + digits[-3:]
        else:
            anon["phone"] = "***"
    return anon


def get_tech_questions(tech_stack):
    """
    Generate technical interview questions using Google Gemini model API based on the candidate's tech stack.

    """
    if not tech_stack.strip():
        return "No tech stack provided."
    prompt = (
        f"You are an experienced technical interviewer. For each of the following technologies, "
        f"write exactly 3 intermediate-level interview questions. Each question must be a single line "
        f"and should NOT include any explanations or answers. Only return the questions, nothing else:\n{tech_stack}"
    )
    try:
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        return f"Couldn't generate questions. Error: {str(e)}"






# 7.Initialize conversation



if st.session_state.stage == "intro" and not st.session_state.conversation:
    st.session_state.conversation.append(
        ("Bot", "Hi! I'm TalentScout, your AI hiring assistant. I will ask a few questions to help us streamline the process. Respond with 'YES' to continue.")
    )
    st.session_state.stage = "consent"


# Main Input Handling & State Logic


user_input = st.chat_input("Type your response...")
if user_input:
    user_input = user_input.strip()
    stage = st.session_state.stage.lower()

    # Append user's message to conversation
    st.session_state.conversation.append(("User", user_input))

    # Handle exit commands
    if any(x in user_input.lower() for x in ["bye", "exit", "thank"]):
        st.session_state.conversation.append(("Bot", "Thanks! Weâ€™ll be in touch soon. ðŸ‘‹"))
        st.session_state.stage = "completed"

    elif stage == "intro":
        # Redundant, since we start at intro and immediately move to consent.
        st.session_state.conversation.append(("Bot", "Hi! I'm TalentScout, your AI hiring assistant. Ready to begin? (yes/no)"))
        st.session_state.stage = "consent"

    elif stage == "consent":
        if "yes" in user_input.lower():
            st.session_state.conversation.append(("Bot", "Awesome! Let's begin."))
            st.session_state.stage = "full_name"
            st.session_state.conversation.append(("Bot", stages[0][1]))
        elif "no" in user_input.lower():
            st.session_state.conversation.append(("Bot", "Okay, feel free to return anytime. ðŸ‘‹"))
            st.session_state.stage = "completed"
        else:
            st.session_state.conversation.append(("Bot", "Please reply with 'yes' or 'no'."))

    elif stage in [s[0] for s in stages if s[0] != "tech_stack"]:
        # Validate input for stages other than tech_stack
        if not is_valid(stage, user_input):
            st.session_state.conversation.append(("Bot", f"That doesn't look like a valid {stage.replace('_', ' ')}. Try again?"))
        else:
            st.session_state.candidate[stage] = user_input
            next_index = [s[0] for s in stages].index(stage) + 1
            st.session_state.stage = stages[next_index][0]
            st.session_state.conversation.append(("Bot", stages[next_index][1]))

    elif stage == "tech_stack":
        # Validate tech stack input
        if not is_valid(stage, user_input):
            st.session_state.conversation.append(("Bot", "Please provide a valid tech stack to continue."))
        else:
            st.session_state.candidate[stage] = user_input
            st.session_state.conversation.append(("Bot", "Generating technical questions..."))

            questions_text = get_tech_questions(user_input)
            questions_list = [q.strip() for q in questions_text.split('\n') if q.strip()]

            if len(questions_list) == 0:
                st.session_state.conversation.append(("Bot", "Couldn't parse questions from the response. Ending the session."))
                st.session_state.stage = "completed"
            else:
                st.session_state.questions = questions_list
                st.session_state.current_q_index = 0
                st.session_state.answers = {}
                st.session_state.stage = "tech_qna"
                st.session_state.conversation.append(("Bot", "Answer a few questions to help us understand you better."))
                st.session_state.conversation.append(("Bot", st.session_state.questions[0]))

    elif stage == "tech_qna":
        idx = st.session_state.current_q_index
        st.session_state.answers[idx] = user_input

        next_idx = idx + 1
        if next_idx < len(st.session_state.questions):
            st.session_state.current_q_index = next_idx
            st.session_state.conversation.append(("Bot", st.session_state.questions[next_idx]))
        else:
            st.session_state.conversation.append(("Bot", "Thank you for your responses. Our team will get in touch with you soon!"))

            # Anonymize and store candidate info and answers (simulated backend)
            candidate_anonymized = anonymize(st.session_state.candidate)
            stored_entry = {
                "candidate_info": candidate_anonymized,
                "technical_answers": st.session_state.answers.copy(),
            }
            st.session_state.stored_data.append(stored_entry)

            st.session_state.stage = "completed"

    elif stage == "completed":
        st.session_state.conversation.append(("Bot", "The session is already complete."))


# 8. Data Collection and Render Conversation UI


for role, msg in st.session_state.conversation:
    with st.chat_message("user" if role == "User" else "assistant"):
        st.markdown(msg)

# Expandable anonymized data viewer (demo/debug)


with st.expander("View anonymized collected data (for demo only)"):
    st.json(st.session_state.stored_data)

